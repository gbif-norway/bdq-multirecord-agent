"""
Full Pipeline End-to-End Tests for BDQ Email Processing Service

These tests cover the complete email processing pipeline including the /email/incoming endpoint
with proper mocking of the BDQ service to avoid Java dependency issues.
"""

import pytest
import json
import base64
import os
from unittest.mock import patch, MagicMock, AsyncMock
from fastapi.testclient import TestClient
import pandas as pd


class TestE2EFullPipeline:
    """Full pipeline end-to-end tests for the BDQ email processing service"""

    @pytest.fixture
    def sample_occurrence_csv(self):
        """Load sample occurrence CSV data"""
        csv_path = os.path.join(os.path.dirname(__file__), "data", "simple_occurrence_dwc.csv")
        with open(csv_path, 'r') as f:
            return f.read()

    @pytest.fixture
    def mock_email_data_occurrence(self, sample_occurrence_csv):
        """Create mock email data for occurrence core"""
        csv_b64 = base64.b64encode(sample_occurrence_csv.encode('utf-8')).decode('utf-8')
        return {
            "receivedAt": "2024-01-15T10:30:00Z",
            "messageId": "test-message-123",
            "threadId": "test-thread-456",
            "historyId": "12345",
            "labelIds": ["INBOX"],
            "snippet": "Test occurrence data for BDQ processing",
            "headers": {
                "subject": "Test Occurrence Data",
                "from": "test@example.com",
                "to": "bdq-service@example.com",
                "cc": "",
                "date": "Mon, 15 Jan 2024 10:30:00 +0000",
                "messageId": "<test-message-123@example.com>",
                "inReplyTo": "",
                "references": ""
            },
            "body": {
                "text": "Please process this occurrence data for BDQ testing.",
                "html": "<p>Please process this occurrence data for BDQ testing.</p>"
            },
            "attachments": [
                {
                    "filename": "simple_occurrence_dwc.csv",
                    "mimeType": "text/csv",
                    "size": len(sample_occurrence_csv),
                    "contentBase64": csv_b64
                }
            ]
        }

    @pytest.fixture
    def client(self):
        """Create test client with mocked BDQ service"""
        # Mock the BDQ service at the module level to prevent Java initialization
        with patch('app.services.bdq_py4j_service.BDQPy4JService') as mock_bdq_class:
            # Create a mock instance
            mock_bdq_instance = MagicMock()
            mock_bdq_class.return_value = mock_bdq_instance
            
            # Mock the methods we need
            mock_test = MagicMock()
            mock_test.label = "Test Validation"
            mock_test.acted_upon = ["countryCode"]
            mock_test.consulted = []
            mock_test.java_class = "TestClass"
            mock_test.java_method = "testMethod"
            mock_test.test_type = "Validation"
            
            mock_bdq_instance.get_applicable_tests_for_dataset.return_value = [mock_test]
            
            # Mock test execution result
            mock_test_result = {
                'status': 'RUN_HAS_RESULT',
                'result': 'COMPLIANT',
                'comment': 'Test passed',
                'amendment': None
            }
            mock_bdq_instance.execute_single_test.return_value = mock_test_result
            
            # Now import and create the app
            from app.main import app
            return TestClient(app)

    @pytest.fixture
    def mock_llm_response(self):
        """Mock LLM service response"""
        return "This is a test summary generated by the LLM service. The data quality analysis shows 3 compliant records and 2 records with validation issues."

    @pytest.fixture
    def mock_csv_responses(self):
        """Mock CSV service responses"""
        return {
            'raw_results': "record_id,test_id,status,result,comment\nocc1,test1,RUN_HAS_RESULT,COMPLIANT,Test passed\nocc2,test1,RUN_HAS_RESULT,NOT_COMPLIANT,Test failed",
            'amended_dataset': "occurrenceID,eventDate,country,countryCode,decimalLatitude,decimalLongitude,scientificName,basisOfRecord\nocc1,2023-01-01,United States,US,37.7749,-122.4194,Homo sapiens,HumanObservation"
        }

    @patch('app.services.email_service.EmailService.send_reply')
    @patch('app.services.llm_service.LLMService.generate_intelligent_summary')
    @patch('app.services.csv_service.CSVService.generate_raw_results_csv')
    @patch('app.services.csv_service.CSVService.generate_amended_dataset')
    def test_full_pipeline_success(
        self,
        mock_generate_amended_dataset,
        mock_generate_raw_results_csv,
        mock_llm_summary,
        mock_send_reply,
        client,
        mock_email_data_occurrence,
        mock_llm_response,
        mock_csv_responses
    ):
        """Test the complete pipeline from email reception to reply sending"""
        
        # Setup mocks
        mock_llm_summary.return_value = mock_llm_response
        mock_generate_raw_results_csv.return_value = mock_csv_responses['raw_results']
        mock_generate_amended_dataset.return_value = mock_csv_responses['amended_dataset']
        mock_send_reply.return_value = AsyncMock()

        # Send request to /email/incoming endpoint
        response = client.post("/email/incoming", json=mock_email_data_occurrence)
        
        # Verify immediate response
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "accepted"
        assert data["message"] == "Email queued for processing"

        # Give async task time to complete
        import time
        time.sleep(0.5)

        # Verify that the LLM service was called
        mock_llm_summary.assert_called_once()
        
        # Verify that CSV services were called
        mock_generate_raw_results_csv.assert_called_once()
        mock_generate_amended_dataset.assert_called_once()
        
        # Verify that email reply was sent
        mock_send_reply.assert_called_once()
        
        # Verify the email reply call arguments
        call_args = mock_send_reply.call_args
        email_data_arg = call_args[0][0]
        body_arg = call_args[0][1]
        attachments_arg = call_args[0][2]
        
        # Verify email data
        assert email_data_arg["messageId"] == "test-message-123"
        assert email_data_arg["threadId"] == "test-thread-456"
        
        # Verify LLM-generated body
        assert mock_llm_response in body_arg
        
        # Verify attachments
        assert len(attachments_arg) == 2
        
        # Check raw results attachment
        raw_results_attachment = next(att for att in attachments_arg if att["filename"] == "bdq_raw_results.csv")
        assert raw_results_attachment["mimeType"] == "text/csv"
        assert raw_results_attachment["contentBase64"] is not None
        
        # Decode and verify raw results content
        raw_results_content = base64.b64decode(raw_results_attachment["contentBase64"]).decode('utf-8')
        assert "record_id,test_id,status,result,comment" in raw_results_content
        assert "occ1,test1,RUN_HAS_RESULT,COMPLIANT" in raw_results_content
        
        # Check amended dataset attachment
        amended_dataset_attachment = next(att for att in attachments_arg if att["filename"] == "amended_dataset.csv")
        assert amended_dataset_attachment["mimeType"] == "text/csv"
        assert amended_dataset_attachment["contentBase64"] is not None
        
        # Decode and verify amended dataset content
        amended_dataset_content = base64.b64decode(amended_dataset_attachment["contentBase64"]).decode('utf-8')
        assert "occurrenceID,eventDate,country" in amended_dataset_content
        assert "occ1,2023-01-01,United States" in amended_dataset_content

    @patch('app.services.email_service.EmailService.send_reply')
    def test_full_pipeline_no_attachment_error(
        self,
        mock_send_reply,
        client
    ):
        """Test the pipeline with no CSV attachment"""
        
        mock_send_reply.return_value = AsyncMock()
        
        # Create email data without attachments
        email_data_no_attachment = {
            "receivedAt": "2024-01-15T10:30:00Z",
            "messageId": "test-message-124",
            "threadId": "test-thread-457",
            "historyId": "12346",
            "labelIds": ["INBOX"],
            "snippet": "Test email without CSV attachment",
            "headers": {
                "subject": "Test Email No Attachment",
                "from": "test@example.com",
                "to": "bdq-service@example.com",
                "cc": "",
                "date": "Mon, 15 Jan 2024 10:30:00 +0000",
                "messageId": "<test-message-124@example.com>",
                "inReplyTo": "",
                "references": ""
            },
            "body": {
                "text": "This email has no CSV attachment.",
                "html": "<p>This email has no CSV attachment.</p>"
            },
            "attachments": []
        }

        # Send request
        response = client.post("/email/incoming", json=email_data_no_attachment)
        
        # Verify immediate response
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "accepted"
        assert data["message"] == "Email queued for processing"

        # Give async task time to complete
        import time
        time.sleep(0.5)

        # Verify error reply was sent
        mock_send_reply.assert_called_once()
        
        # Verify error message
        call_args = mock_send_reply.call_args
        body_arg = call_args[0][1]
        assert "No CSV attachment found" in body_arg

    @patch('app.services.email_service.EmailService.send_reply')
    def test_full_pipeline_invalid_csv_error(
        self,
        mock_send_reply,
        client
    ):
        """Test the pipeline with invalid CSV (no core type)"""
        
        mock_send_reply.return_value = AsyncMock()
        
        # Create email data with invalid CSV
        invalid_csv = "not,a,valid,csv\nwith,missing,columns"
        csv_b64 = base64.b64encode(invalid_csv.encode('utf-8')).decode('utf-8')
        
        email_data_invalid_csv = {
            "receivedAt": "2024-01-15T10:30:00Z",
            "messageId": "test-message-125",
            "threadId": "test-thread-458",
            "historyId": "12347",
            "labelIds": ["INBOX"],
            "snippet": "Test email with invalid CSV",
            "headers": {
                "subject": "Test Email Invalid CSV",
                "from": "test@example.com",
                "to": "bdq-service@example.com",
                "cc": "",
                "date": "Mon, 15 Jan 2024 10:30:00 +0000",
                "messageId": "<test-message-125@example.com>",
                "inReplyTo": "",
                "references": ""
            },
            "body": {
                "text": "This email has an invalid CSV attachment.",
                "html": "<p>This email has an invalid CSV attachment.</p>"
            },
            "attachments": [
                {
                    "filename": "invalid.csv",
                    "mimeType": "text/csv",
                    "size": len(invalid_csv),
                    "contentBase64": csv_b64
                }
            ]
        }

        # Send request
        response = client.post("/email/incoming", json=email_data_invalid_csv)
        
        # Verify immediate response
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "accepted"
        assert data["message"] == "Email queued for processing"

        # Give async task time to complete
        import time
        time.sleep(0.5)

        # Verify error reply was sent
        mock_send_reply.assert_called_once()
        
        # Verify error message
        call_args = mock_send_reply.call_args
        body_arg = call_args[0][1]
        assert "occurrenceID" in body_arg and "taxonID" in body_arg

    def test_health_endpoints(self, client):
        """Test health check endpoint"""
        
        # Test root endpoint
        response = client.get("/")
        assert response.status_code == 200
        data = response.json()
        assert data["message"] == "BDQ Email Report Service is running"
        
    def test_invalid_json_request(self, client):
        """Test handling of invalid JSON request"""
        response = client.post("/email/incoming", data="invalid json")
        assert response.status_code == 400  # Custom JSON decode error
        data = response.json()
        assert data["status"] == "error"
        assert "Invalid JSON" in data["message"]

    @patch('app.services.email_service.EmailService.send_reply')
    def test_full_pipeline_with_txt_attachment(
        self,
        mock_send_reply,
        client,
        sample_occurrence_csv
    ):
        """Test the pipeline with .txt attachment (should be treated as CSV)"""
        
        mock_send_reply.return_value = AsyncMock()
        
        # Create email data with .txt attachment
        csv_b64 = base64.b64encode(sample_occurrence_csv.encode('utf-8')).decode('utf-8')
        
        email_data_txt_attachment = {
            "receivedAt": "2024-01-15T10:30:00Z",
            "messageId": "test-message-126",
            "threadId": "test-thread-459",
            "historyId": "12348",
            "labelIds": ["INBOX"],
            "snippet": "Test email with .txt CSV attachment",
            "headers": {
                "subject": "Test Email TXT Attachment",
                "from": "test@example.com",
                "to": "bdq-service@example.com",
                "cc": "",
                "date": "Mon, 15 Jan 2024 10:30:00 +0000",
                "messageId": "<test-message-126@example.com>",
                "inReplyTo": "",
                "references": ""
            },
            "body": {
                "text": "This email has a .txt attachment that should be treated as CSV.",
                "html": "<p>This email has a .txt attachment that should be treated as CSV.</p>"
            },
            "attachments": [
                {
                    "filename": "data.txt",
                    "mimeType": "text/plain",
                    "size": len(sample_occurrence_csv),
                    "contentBase64": csv_b64
                }
            ]
        }

        # Send request
        response = client.post("/email/incoming", json=email_data_txt_attachment)
        
        # Verify immediate response
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "accepted"
        assert data["message"] == "Email queued for processing"

        # Give async task time to complete
        import time
        time.sleep(0.5)

        # Verify that processing succeeded (no error reply sent)
        # The mock should be called for successful processing, not error handling
        # This test verifies that .txt files are properly recognized as CSV attachments
